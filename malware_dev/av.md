| üè† [Home](../../pentesting.md) | ‚¨ÖÔ∏è ‚¨ÖÔ∏è [Part](../_part) | ‚¨ÖÔ∏è [Chapter](./_chapter) |
|--------------------------------|----------------------|-------------------------|

-   [Antivirus](#antivirus){#toc-antivirus}
    -   [Signature databases](#signature-databases){#toc-signature-databases}
    -   [Static analysis](#static-analysis){#toc-static-analysis}
    -   [Heuristic and behavioural detection](#heuristic-and-behavioural-detection){#toc-heuristic-and-behavioural-detection}
    -   [Import Address Table (IAT) inspection](#import-address-table-iat-inspection){#toc-import-address-table-iat-inspection}
    -   [Antimalware Scan Interface AMSI)](#antimalware-scan-interface-amsi){#toc-antimalware-scan-interface-amsi}
        -   [links](#links){#toc-links}
    -   [Event Tracing for Windows ETW)](#event-tracing-for-windows-etw){#toc-event-tracing-for-windows-etw}
        -   [links](#links-1){#toc-links-1}
    -   [API Hooking](#api-hooking){#toc-api-hooking}
    -   [Network detection](#network-detection){#toc-network-detection}
    -   [Defender Signature Database](#defender-signature-database){#toc-defender-signature-database}
        -   [Decompressing database](#decompressing-database){#toc-decompressing-database}
    -   [Searching database](#searching-database){#toc-searching-database}
    -   [Tools](#tools){#toc-tools}
        -   [DefenderCheck](#defendercheck){#toc-defendercheck}
    -   [links](#links-2){#toc-links-2}

# Antivirus

## Signature databases

Signature-based analysis involves storing a list of all signatures known
to belong to malicious programs, and then comparing each new signature
with this list.

Although this approach is interesting, it is not sufficient on its own
to guarantee the effectiveness of an antivirus. In fact, it is
relatively easy to bypass. The slightest change, however minor, in a
program will completely alter its signature.

Furthermore, this security method does not protect against new threats
whose signatures are not yet listed.

## Static analysis

Static analysis consists of searching a program for one or more strings
of characters known to belong to a malicious program.

## Heuristic and behavioural detection

The aim of heuristic detection is to understand how a program works and
to determine what actions it is about to perform on a system.

This can be achieved by using a sandbox: an isolated virtual machine in
which the potentially dangerous program can run. The antivirus software
can then check the actions taken by the program during execution and
look for indicators of malicious action.

Similarly, behavioural detection consists of observing the actions
performed by a program during execution in order to spot any suspicious
activity.

For example, certain calls to the Windows API made in a certain order
are known to be typical malware patterns.

## Import Address Table (IAT) inspection

The Import Address Table is a table relating to each Portable Executable
(contained in the import directory of the PE's optional header) which
contains a list of loaded DLLs and their exported functions used by the
program.

his table is observed by most antivirus software, and the presence of
certain functions can trigger an alert.

For example, the presence of the functions "OpenProcess",
"VirtualAllocEx", "WriteProcessMemory" and "CreateRemoteThreadEx" (all
exported by "kernel32.dll") together in the same program will make it
highly suspect. These 4 functions used together enable process injection
techniques often used by malicious programs.

[Import Adress Table (IAT)
Hooking](https://www.ired.team/offensive-security/code-injection-process-injection/import-adress-table-iat-hooking)

## Antimalware Scan Interface (AMSI)

AMSI is an interface provided by the Windows operating system that any
developer can use to integrate antivirus protection into their program.

More specifically, developers can choose to load the `AMSI.dll` DLL into
their program and use the functions exported by this DLL. For example,
the `AmsiScanString\verb` function takes a string of characters as input
and returns `AMSI_RESULT_CLEAN` if no threat is detected and
`AMSI_RESULT_DETECTED` otherwise.

AMSI therefore acts as a bridge between a given program and an antivirus

### links

-   [Maelstrom 6: Working with AMSI and ETW for Red and
    Blue](https://pre.empt.blog/2023/maelstrom-6-working-with-amsi-and-etw-for-red-and-blue)

## Event Tracing for Windows (ETW)

ETW is a mechanism for tracking and logging a large number of events
triggered by applications and drivers. Historically, ETW was mainly used
for debugging purposes. Over time, the large amount of data reported by
this system became of interest to vendors of protection solutions, who
saw an opportunity to detect malicious activity by analysing the flows
reported by the ETW.

ETW is made up of three distinct components:

-   Providers: **Threat Intelligence provider** In several places in the
    Windows code associated with critical functionalities, function
    calls associated with the Event Tracing for Windows -- Threat
    Intelligence provider are observed. For example, the
    `MiReadWriteVirtualMemory` function makes a call to
    `EtwTiLogReadWriteVm`

-   Consumers: various programs that will use the logs provided by the
    suppliers to act accordingly.

-   Controllers: software components responsible for managing the event
    tracing process. Their main role is to initiate, monitor and control
    tracing sessions.

It should therefore be noted that for most of the actions we perform on
a Windows system, event logs are sent back to the antivirus/EDR, which
adds another method of detecting suspicious actions.

### links

-   [Maelstrom 6: Working with AMSI and ETW for Red and
    Blue](https://pre.empt.blog/2023/maelstrom-6-working-with-amsi-and-etw-for-red-and-blue)

## API Hooking

Most Windows API functions are exported by `kernel32.dll`. These
functions do not communicate directly with the kernel; to do so, they
must use syscalls.

These system calls act as an interface enabling programs to interact
with the Windows operating system. Most of them are exported as
`ntdll.dll`, and the naming convention is that they begin with the
letters `Nt`

very few actions are performed inside `Nt` functions. This is because,
most of its code is actually in the kernel. The `ntdll` versions of
these functions simply perform syscalls to invoke their kernel-mode
counterparts.

When a security solution (such as an EDR) is installed on a machine, it
may seek to perform API hooking. To do this, the security solution will
monitor the machine to detect the creation of new processes.

When a new process is launched, the EDR will inject its own DLL into it.
The EDR will look for the memory addresses of other DLLs whose functions
it wishes to monitor. For example, an EDR wishing to monitor
`NtProtectVirtualMemory` of `ntdll.dll` will first find the base address
of `ntdll.dll` in the injected process, then the address of the
`NtProtectVirtualMemory` function.

Once these actions have been carried out, the EDR will replace the first
bytes at the base address of the targeted function (responsible for
executing the syscall) with bytes corresponding to a jump instruction
(`jmp`) to the code of its own DLL.

In this way, the EDR is free to perform the security tests it deems
necessary and is able to monitor any calls to Windows API functions.

This will allow to defend against Address Import Table (IAT) evastion
technics

## Network detection

Finally, some security solutions may monitor the connections made by the
machine and block a threat based on certain indicators.

For example, a block might be decided if a program initiates a
connection to an IP address known to be associated with malicious
servers. This strengthens security by preventing malicious software from
communicating with dangerous servers.

## Defender Signature Database

`Get-MpThreatCatalog` Get Access to Threat database.

### Decompressing database

The following script developed by Matt Graeber decompresses Windows
Defender Antivirus signatures.
`C:\ProgramData\Microsoft\Windows Defender\Definition Updates\{GUID}\mpavbase.vdm`

    filter Expand-DefenderAVSignatureDB {
    <#
    .SYNOPSIS

    Decompresses a Windows Defender AV signature database (.VDM file).

    .DESCRIPTION

    Expand-DefenderAVSignatureDB extracts a Windows Defender AV signature database (.VDM file). This function was developed by reversing mpengine.dll and with the help of Tavis Ormandy and his LoadLibrary project (https://github.com/taviso/loadlibrary). Note: Currently, "scrambled" databases are not supported although, I have yet to encounter a scrambled database. Thus far, all databases I've encountered are zlib-compressed.

    .PARAMETER FilePath

    Specifies the path to a Defender AV signature file. Defender AV signature databases are stored in "%ProgramData%\Microsoft\Windows Defender\Definition Updates\{GUID}\*.vdm". The file path must have the .vdm extension.

    .PARAMETER OutputFileName

    Specifies the filename of the extracted signature database. This is written to the current working directory.

    .EXAMPLE

    ls 'C:\ProgramData\Microsoft\Windows Defender\Definition Updates\{42F61A44-8142-4AF4-8E13-6EA18B60C397}\mpavbase.vdm' | Expand-DefenderAVSignatureDB -OutputFileName mpavbase.decompressed

    Extracts the signature database from mpavbase.vdm and writes it to mpavbase.decompressed in the current directory.

    .OUTPUTS

    System.IO.FileInfo

    Outputs a FileInfo object indicating successful extraction of the .VDM file.
    #>

        [OutputType([System.IO.FileInfo])]
        param (
            [Parameter(Mandatory, ValueFromPipelineByPropertyName)]
            [String]
            [Alias('FullName')]
            [ValidateScript({$_.EndsWith('.vdm')})]
            $FilePath,

            [Parameter(Mandatory)]
            [String]
            [ValidateNotNullOrEmpty()]
            $OutputFileName
        )

        if (-not (Test-Path -Path $FilePath)) {
            Write-Error "$FilePath does not exist"
            return
        }

        $FileFullPath = Resolve-Path -Path $FilePath

        $FileBytes = [IO.File]::ReadAllBytes($FileFullPath.Path)

        if ([Text.Encoding]::ASCII.GetString($FileBytes[0..1]) -ne 'MZ') {
            Write-Error "$FileFullPath is not a valid PE file."
            return
        }

        # Note: Codepage 28591 returns a 1-to-1 char to byte mapping
        $Encoding = [Text.Encoding]::GetEncoding(28591)

        $FileString = $Encoding.GetString($FileBytes)

        # Most of this logic is present in mpengine!load_database and subsequent function calls

        $DatabaseSigRegex = [Regex] 'RMDX'

        $Result = $DatabaseSigRegex.Match($FileString)

        if (-not $Result.Success) {
            Write-Error 'Defender AV signature database header signature ("RMDX") was not found'
            return
        }

        $HeaderIndex = $Result.Index
        $HeaderSize = 0x40

        [Byte[]] $HeaderBytes = $FileBytes[$HeaderIndex..($HeaderIndex + $HeaderSize - 1)]

        $Options = [BitConverter]::ToInt32($HeaderBytes, 0x0C)
        $MaybeChecksum = [BitConverter]::ToInt32($HeaderBytes, 0x1C)
        $LastFieldUnknown = [BitConverter]::ToInt32($HeaderBytes, 0x3C)

        $IsCompressed = [Bool][Byte](($Options -shr 1) -band 0xFF)

        if (-not $IsCompressed) {
            Write-Warning 'Signature database is "scrambled". Figure out how to programmatically recover this. Unable to continue.'
            return
        }

        # Offset to the compressed data info from the start of the sig db header
        $CompressedDataInfoOffset = [BitConverter]::ToInt32($HeaderBytes, 0x18)

        if ((($Options -band 0x200000) -eq 0) -or ($MaybeChecksum -eq 0) -or ($LastFieldUnknown -eq 0)) {
            Write-Error "Invalid Defender AV signature database header."
            return
        }

        $CompressedDataLength = [BitConverter]::ToInt32($FileBytes, $HeaderIndex + $CompressedDataInfoOffset)
        $CompressedDataChecksumMaybe = [BitConverter]::ToInt32($FileBytes, $HeaderIndex + $CompressedDataInfoOffset + 4)
        $CompressedDataIndex = $HeaderIndex + $CompressedDataInfoOffset + 8

        # To-do: this is slow. I need to figure out how to speed up array splicing
        $CompressedData = $FileBytes[$CompressedDataIndex..($CompressedDataIndex + $CompressedDataLength - 1)]

        $MemoryStream = New-Object -TypeName IO.MemoryStream -ArgumentList @(,$CompressedData)

        # Write the decompressed signature database contents to the filename specified in the current directory.
        $DecompressedFileStream = [IO.File]::Create("$PWD\$OutputFileName")

        $DeflateStream = New-Object IO.Compression.DeflateStream -ArgumentList ($MemoryStream, [IO.Compression.CompressionMode]::Decompress)

        try {
            $DeflateStream.CopyTo($DecompressedFileStream)
        } catch {
            Write-Error $_
        } finally {
            $DeflateStream.Close()
            $DecompressedFileStream.Close()
            $MemoryStream.Close()
        }

        Get-Item -Path "$PWD\$OutputFileName"
    }

## Searching database

    Import-Module C:\Tools\ExpandDefenderSig\ExpandDefenderSig.ps1
    ls "C:\ProgramData\Microsoft\Windows Defender\Definition Updates\{50326593-AC5A-4EB5-A3F0-047A75D1470C}\mpavbase.vdm" | Expand-DefenderAVSignatureDB -OutputFileName mpavbase.raw
    C:\Tools\Strings\strings64.exe .\mpavbase.raw | Select-String -Pattern "WNcry@2ol7"

in theory it is possible to delete signature file or

    C:\ProgramData\Microsoft\Windows Defender\Platform\4.18.2008.9-0\MpCmdRun.exe -RemoveDefinitions -All

## Tools

### DefenderCheck

[DefenderCheck](https://github.com/matterpreter/DefenderCheck) Takes a
binary as input and splits it until it pinpoints that exact byte that
Microsoft Defender will flag on, and then prints those offending bytes
to the screen. This can be helpful when trying to identify the specific
bad pieces of code in your tool/payload.

## links

-   [Antivirus and EDR Bypass Techniques
    ](https://www.vaadata.com/blog/antivirus-and-edr-bypass-techniques/#how-does-an-antivirus-edr-work)
