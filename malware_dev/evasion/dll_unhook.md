| üè† [Home](../../redteam.md) | ‚¨ÖÔ∏è ‚¨ÖÔ∏è [Part](../_part) | ‚¨ÖÔ∏è [Chapter](./_chapter) |
|-----------------------------|----------------------|-------------------------|

* [Dll unhooking](../../malware_dev/evasion/dll_unhook.md)
    * [Introduction](../../malware_dev/evasion/dll_unhook.md#introduction)
    * [links](../../malware_dev/evasion/dll_unhook.md#links)


# Dll unhooking

## Introduction

EDR use hooking to monitor sensitive system functions within the DLLs of loaded processes. Hooking is a method of live-patching system DLLs, enabling EDRs to intercept the flow of a program and evaluate its legitimacy.

EDRs modify the first instructions of the functions within the DLLs. When these functions are called, the program's execution flow is diverted to the EDR's code (housed within a DLL loaded by the EDR in the program). In this redirected state, the EDR can inspect the function's arguments to determine whether their usage is legitimate or potentially malicious. If the usage is deemed legitimate, the EDR restores the program's execution flow, allowing the function to proceed as normal.

DLL unhooking involves restoring the entire DLL code section (`.text`) to its original state. To accomplish this, malware needs access to an unhooked DLL, which it can acquire in several ways:

* directly from the system, which can potentially be detected via an open handle;
* by opening a remote file, (requires to host a DLL matching the OS version of the target system);
* by initiating a suspended process and retrieving the content of its DLL before it gets hooked.

Typically, the DLL most commonly hooked/unhooked is `NTDLL.dll`, as it is the closest to the kernel. However, some EDRs may also hook APIs contained in higher-level DLLs, such as `kernel32.dll` or `user32.dll`.


## Turning ntdll into a reflective dll (pe_to_shellcode)
* [pe_to_shellcode](https://github.com/hasherezade/pe_to_shellcode)
* [Unholy Unhooking: FrByoDLL](https://steve-s.gitbook.io/0xtriboulet/archive/notice/unholy-unhooking/unholy-unhooking-frbyodll)
copy of ntdll into a reflective DLL, load it into a sacrificial thread, then copy it over the hooked copy of ntdll and thereby unhook our process.

pe2shc <dll_path|C:\Windows\System32\ntdll.dll> <shellcode_path|./ntdll.bin>

## links
* [Full DLL Unhooking with C++](https://www.ired.team/offensive-security/defense-evasion/how-to-unhook-a-dll-using-c++)
* [C++ template for DLL Unhooking + ETW patching](https://github.com/ProcessusT/UnhookingDLL)
* [Staying Under the Radar - Part 3 - Unhooking DLLs](https://crypt0ace.github.io/posts/Staying-under-the-Radar-Part-3/)