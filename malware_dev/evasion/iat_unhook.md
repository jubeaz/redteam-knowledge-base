| üè† [Home](../../redteam.md) | ‚¨ÖÔ∏è ‚¨ÖÔ∏è [Part](../_part) | ‚¨ÖÔ∏è [Chapter](./_chapter) |
|-----------------------------|----------------------|-------------------------|

* [IAT unhook](../../malware_dev/evasion/iat_unhook.md)
    * [Introduction](../../malware_dev/evasion/iat_unhook.md#introduction)
    * [links](../../malware_dev/evasion/iat_unhook#links)

# IAT unhook

## Introduction

[PE import](../../knowledge/portable_executable/import.md)

Imagine you‚Äôre building a large Lego structure, and you need some special Lego pieces that you don‚Äôt have in your collection. So, you ask your friend to lend you those pieces. However, you don‚Äôt know exactly where your friend keeps those pieces in their Lego collection.

To solve this, your friend gives you a list of the names of the special Lego pieces you need and tells you that they will put a sticker on each piece indicating where to find it in their collection. This list is like the Import Directory in Windows.

When you receive the list, you start building your structure. When you come across a part that you need from your friend‚Äôs collection, you refer to the list to know which piece to take. You check the sticker on that piece, which tells you exactly where to find it. This sticker is like the Import Address Table (IAT).

So, the IAT is like a table that holds the memory addresses of functions (Lego pieces) you need from external libraries (your friend‚Äôs Lego collection). It helps your program find the right functions at runtime without having to know the exact memory addresses.

Initially, the IAT contains placeholders or thunks instead of the actual memory addresses. These placeholders act as reminders that the addresses need to be filled in later. When your program starts running, the operating system takes care of replacing the placeholders in the IAT with the real memory addresses of the functions you need from the DLLs.

When your program wants to use one of those functions, it looks up the IAT entry for that function and jumps to the memory address stored there. It‚Äôs like you finding the Lego piece you need based on the sticker on it and using it to continue building your structure.

The IAT provides flexibility and allows programs to import functions from DLLs dynamically. It makes the software development process more modular and helps manage memory efficiently.

On the flip side, the IAT can be targeted by attackers who might try to modify the table entries to redirect function calls to malicious code. To counter such threats, security solutions like EDR keep an eye on the IAT for any suspicious changes, helping protect the system from potential malware attacks.

https://github.com/grisuno/LazyLoader/blob/main/main.c#L293

## links

* [EDR Bypass : How and Why to Unhook the Import Address Table](https://alice.climent-pommeret.red/posts/how-and-why-to-unhook-the-import-address-table/)
* [Anatomy of IAT and EAT Hooking](https://securitymaven.medium.com/anatomy-of-iat-and-eat-hooking-9612eb15baf1)
* [UnhookIAT.c](https://github.com/xalicex/Unhook-Import-Address-Table)
* [AV/EDR Evasion | Malware Development P ‚Äî 4](https://medium.com/@0xHossam/av-edr-evasion-malware-development-p-4-162662bb630e)