| üè† [Home](../../pentesting.md) | ‚¨ÖÔ∏è ‚¨ÖÔ∏è [Part](../_part) | ‚¨ÖÔ∏è [Chapter](./_chapter) |
|--------------------------------|----------------------|-------------------------|

* [DLL](../../malware_dev/knowledge/dll.md)
    * [Introduction](../../malware_dev/knowledge/dll.md#introduction)
        * [DLL search order](../../malware_dev/knowledge/dll.md#dll-search-order)
        * [DllMain](../../malware_dev/knowledge/dll.md#dllmain)
        * [Attacks](../../malware_dev/knowledge/dll.md#attacks)


# DLL

## Introduction

A `DLL` (a type of `PE` file) is a library that contains code and data that can be used by more than one program at the same time.

These libraries are loaded into their own space in the system memory and can be accessed by one or more processes at runtime.

The predefined search for DLLs in Windows

Before searching for the DLL in the system files, Windows does two things. First check if the DLL is already loaded in memory. If yes, the search process stops here. It then checks to see if the DLL belongs to a list known as "Known DLLs". If it is in that list, the system will use its own copy of the DLL.


## DLL search order

* The directory from which the application is loaded

* `C:\Windows\System32`

* `C:\Windows\System`

* `C:\Windows`

* The current working directory

* Directories in the system PATH environment variable

* Directories in the user PATH environment variable

## DllMain

An optional (If omitted, Windows uses a default stub) entry point into a DLL. When the system starts or terminates a process or thread, it calls the entry-point function for each loaded DLL using the first thread of the process. The system also calls the entry-point function for a DLL when it is loaded or unloaded using the `LoadLibrary` and `FreeLibrary` functions.
```c
BOOL WINAPI DllMain(
    _In_ HINSTANCE hinstDLL,
    _In_ DWORD     fdwReason,
    _In_ LPVOID    lpvReserved
);

BOOL APIENTRY DllMain(HMODULE hModule,
    DWORD  ul_reason_for_call,
    LPVOID lpReserved
) {
    switch (ul_reason_for_call) {
    case DLL_PROCESS_ATTACH:
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
```


* `hinstDLL`: Handle (base address) of the DLL module, Same value returned by `LoadLibrary`
* `fdwReason`: reason why the dll is being called. Possible values
    * `DLL_PROCESS_ATTACH`: DLL loaded into a process
    * `DLL_PROCESS_DETACH`: DLL unloaded from a process
    * `DLL_THREAD_ATTACH`: A new thread is created
    * `DLL_THREAD_DETACH`: A thread exits    
* `lpvReserved`: NULL when loaded via `LoadLibrary`, Non-NULL when process termination or static load

### loader lock
* [Perfect DLL Hijacking](https://elliotonsecurity.com/perfect-dll-hijacking/)

DllMain is run under **Loader Lock** which puts some limitations on what can be done safely from Dllmain.

Microsoft ([Dynamic-Link Library Best Practices](https://learn.microsoft.com/en-us/windows/win32/dlls/dynamic-link-library-best-practices)) explicitly warns against:
* Creating threads
* Calling LoadLibrary / FreeLibrary
* Performing synchronization (mutexes, critical sections)
* Calling most Win32 APIs
* Allocating heap memory
* Doing anything slow or complex

What DllMain is for:
* Simple flag initialization
* Setting global variables
* Storing hinstDLL
* Minimal bookkeeping

**If the target program calls an export of your hijackable DLL at some point in its lifetime, then you're golden because you can just redirect code execution from there without having to worry about the struggles of `DllMain` and `Loader Lock` at all.**

#### Racing the Main Thread

As Microsoft states in the aforementioned "Best Practices" documentation, calling `CreateThread` from `DllMain` "can work":

```c
BOOL WINAPI DllMain(HINSTANCE hinstDll, DWORD fdwReason, LPVOID lpvReserved)
{
    switch (fdwReason)
    {
    case DLL_PROCESS_ATTACH:
        // Create a thread
        // Thread runs our "CustomPayloadFunction" (not shown here)
        DWORD threadId;
        HANDLE newThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)CustomPayloadFunction, NULL, 0, &threadId);
    }

    return TRUE;
}
```

And it does! But there's a catch because the thread created by calling CreateThread will wait (in more ways than one) until we leave DllMain to begin execution. Pulling this off then requires that we call CreateThread, allow the program to exit DllMain (Loader Lock and friends are released shortly thereafter), and hope that the thread is created before the main thread exits the program.

Creating a thread is a relatively expensive operation, so if our target program exits fairly quickly, we may not win this race. Perhaps somehow we can improve our chances of success...


### How malware abuses DllMain

Malware authors often avoid putting real logic in DllMain because it is one of the most constrained, fragile, and heavily monitored execution points in Windows.

Some malware uses `DllMain` only to:
* Check environment conditions
* Detect sandboxes
* Disable thread notifications
* Register callbacks indirectly

`DLL_THREAD_ATTACH` / `DLL_THREAD_DETACH` can be abused to:
* Track thread creation
* Trigger logic opportunistically
* Execute code repeatedly without explicit calls

This is fragile, but historically used.

Advanced malware has abused the **loader lock** itself to:
* Stall defensive DLL loading
* Cause deadlocks in security components
* Exploit assumptions in poorly written hooks

### How EDRs monitor DllMain

`DllMain` is a prime inspection point

**DLL load telemetry**:
* Which DLLs load
* Into which processes
* Load order and timing
* Whether the DLL is signed and trusted
* Suspicious signals:
* Unsigned DLLs in high-value processes
* DLLs loaded from user-writable paths
* Unexpected load timing

**Behavior during `PROCESS_ATTACH`**: EDRs closely watch what happens immediately after load. Red flags:
* Memory allocation
* Page protection changes
* API resolution
* Crypto operations
* Unexpected system calls

**API usage correlation** EDRs correlate followed shortly after by dangerous API used

### loader lock on DLL payload

## exported DLL function declaration
Win32-style callback signature
```c
extern "C" __declspec(dllexport)
void CALLBACK RunExample(
    HWND hwnd,
    HINSTANCE hInst,
    LPSTR lpCmdLine,
    int nCmdShow
)
{
}
```
Compatible with VBA / PowerShell:
```c
extern "C" __declspec(dllexport)
void __stdcall RunExample(int value)
{
}
```
* `extern "C`: Disables C++ name mangling to ensures the exported symbol name is exactly `RunExample` Without this, the export name would look like: `?RunExample@@YAXXZ`

* `__declspec(dllexport)`: Tells the linker to export this function from the DLL. Makes it visible in export table, dumpbin /exports, `GetProcAddress`

* `CALLBACK`: Macro for a Windows calling convention, expands to `#define CALLBACK __stdcall` meaning that 
    * Parameters pushed right-to-left
    * Callee cleans the stack
    * Required for compatibility with many Win32 consumers

* `HWND hwnd` handle to a window. It represents The main window associated with the caller Or a parent window for UI operations. Typical uses: Owner for message boxes, Parent for dialogs, Message routing
* `HINSTANCE hInst`: A module instance handle. In practice: the base address of the EXE or DLL. Used to locate Resources (icons, dialogs, strings) Embedded data (`LoadIcon(hInst, MAKEINTRESOURCE(IDI_ICON1));`, `CreateDialog(hInst, MAKEINTRESOURCE(IDD_MAIN), hwnd, DlgProc);`)
* `LPSTR lpCmdLine`: Pointer to a null-terminated ANSI string (command-line arguments which excludes the executable name)
* `int nCmdShow`: A window display flag which indicates how the main window should be shown (`SW_SHOW`, `SW_HIDE`, `SW_MINIMIZE`,...)

## load a DLL in PowerShell and call an exported function

```powershell
$code = @"
using System;
using System.Runtime.InteropServices;

public static class NativeMethods
{
    [DllImport("C:\\Path\\To\\Example.dll", CallingConvention = CallingConvention.StdCall, CharSet = CharSet.Ansi)]
    public static extern void RunExample(
        IntPtr hwnd,
        IntPtr hInst,
        string lpCmdLine,
        int nCmdShow
    );
}
"@

Add-Type -TypeDefinition $code

[NativeMethods]::RunExample(
    [IntPtr]::Zero,      # hwnd
    [IntPtr]::Zero,      # hInst
    "Hello from PowerShell",
    1                    # SW_SHOWNORMAL
)
```

Alternative: Explicit LoadLibrary
```powershell
Add-Type -MemberDefinition @"
[DllImport("kernel32.dll")]
public static extern IntPtr LoadLibrary(string lpFileName);
"@ -Name Kernel32 -Namespace Win32

[Win32.Kernel32]::LoadLibrary("C:\Path\To\Example.dll")
```


## Reflective dll

* [Reflective DLL injection](https://github.com/stephenfewer/ReflectiveDLLInjection)

## Attacks

* [Path Interception by Search Order Hijacking](https://dmcxblue.gitbook.io/red-team-notes-2-0/red-team-techniques/defense-evasion/untitled-5/path-interception-by-search-order-hijacking)

* [Path Interception by PATH Environment Variable](https://dmcxblue.gitbook.io/red-team-notes-2-0/red-team-techniques/defense-evasion/untitled-5/path-interception-by-path-environment-variable)


* [DLL sideloading](https://dmcxblue.gitbook.io/red-team-notes-2-0/red-team-techniques/defense-evasion/untitled-5/dll-side-loading)
