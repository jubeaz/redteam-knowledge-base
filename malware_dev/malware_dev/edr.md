| üè† [Home](../../pentesting.md) | ‚¨ÖÔ∏è ‚¨ÖÔ∏è [Part](../_part) | ‚¨ÖÔ∏è [Chapter](./_chapter) |
|--------------------------------|----------------------|-------------------------|

* [EDR](../../malware_dev/malware_dev/edr.md)
    * [Intoduction](../../malware_dev/malware_dev/edr.md#intoduction)
        * [Drivers](../../malware_dev/malware_dev/edr.md#drivers)
        * [Kernel Callbacks](../../malware_dev/malware_dev/edr.md#kernel-callbacks)
    * [Kernel Callbacks](../../malware_dev/malware_dev/edr.md#kernel-callbacks-1)
    * [links](../../malware_dev/malware_dev/edr.md#links)

# EDR

## Intoduction

EDR is defined as a solution that "records and stores
endpoint-system-level behaviors, uses various data analytics techniques
to detect suspicious system behavior, provides contextual information,
blocks malicious activity, and provides remediation suggestions to
restore affected systems."

EDR comprises two key components:

* the User-Mode (service): monitors activities such as log registries,
    disk operations, memory usage, process execution, and network
    communications

* the Kernel-Mode component utilizes kernel callbacks to detect the
    creation of processes and threads.

EDR employs a technique similar to malware developers by injecting its
code into remote processes and creating hooks, often in functions
provided by ntdll.dll (the closest library to kernel-mode). This allows
EDR to monitor and intercept predefined functions.

When a new user process is created, EDR injects a Dynamic Link Library
(DLL) into the process to hook predefined functions. This DLL logs
information about the process, contributing to the overall detection and
response capabilities of EDR.

The logged information is crucial for analysis and response. EDR stores
this data either locally, in an internal organization database, or in a
cloud-based EDR solution. Cloud-based EDR often utilizes artificial
intelligence (AI) to handle and process large volumes of information
effectively.

### Drivers

A driver is a software component of Windows which allows the operating
system and device to communicate with each other. In the case of
Endpoint Protection, there are a few reasons why drivers are useful:

* The use of [Callback Objects](https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/callback-objects)
    which allows for a function to be called if an action occurs. For
    example, later on we will see the usage of
    [PsSetLoadImageNotifyRoutine](https://pre.empt.dev/posts/maelstrom-edr-kernel-callbacks-hooks-and-callstacks/PsSetLoadImageNotifyRoutine)
    which is the call-back object for DLLs being loaded.

* Access to privileged information from Event Tracing for Windows
    Threat Intelligence which is only accessible from the Kernel with an
    ELAM Driver.

### Kernel Callbacks

The [kernel's callback mechanism](https://docs.microsoft.com/en-us/windows-hardware/drivers/kernel/callback-objects)
provides a general way for drivers to request and provide notification
when certain conditions are satisfied.

Essentially, they allow drivers to receive and handle notifications for
specific events.

## Kernel Callbacks

[Understanding Telemetry: Kernel Callbacks](https://jsecurity101.medium.com/understanding-telemetry-kernel-callbacks-1a97cfcb8fb3)

## links

* [Understanding EDR from a Red Teamer's Perspective](https://medium.com/@s12deff/understanding-edr-from-a-red-teamers-perspective-f4fe32b5608a)

* [Maelstrom 5: EDR Kernel Callbacks, Hooks, and Call Stacks](https://pre.empt.blog/2023/maelstrom-5-edr-kernel-callbacks-hooks-and-call-stacks)
