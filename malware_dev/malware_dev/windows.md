| üè† [Home](../../pentesting.md) | ‚¨ÖÔ∏è ‚¨ÖÔ∏è [Part](../_part) | ‚¨ÖÔ∏è [Chapter](./_chapter) |
|--------------------------------|----------------------|-------------------------|

* [Windows](../../malware_dev/malware_dev/windows.md)
    * [COFF](../../malware_dev/malware_dev/windows.md#coff)
    * [Native API](../../malware_dev/malware_dev/windows.md#native-api)
    * [DLL](../../malware_dev/malware_dev/windows.md#dll)
        * [DLL search order](../../malware_dev/malware_dev/windows.md#dll-search-order)
        * [DllMain](../../malware_dev/malware_dev/windows.md#dllmain)
        * [Attacks](../../malware_dev/malware_dev/windows.md#attacks)

# Windows

## COFF

* [CoffLoader](https://otterhacker.github.io/Malware/CoffLoader.html)

## Native API

Applications that use the WinAPI will traverse through to the Native API
(NTAPI) which operates within Kernel Mode.

The Native API is a lightweight API used by Windows NT's kernel and user
mode applications. This API is used in the early stages of Windows NT
startup process, when other components and APIs are still unavailable.
Therefore, a few Windows components, such as the Client/Server Runtime
Subsystem (CSRSS), are implemented using the Native API. The Native API
is also used by subroutines such as those in `kernel32.dll` that
implement the Windows API, the API based on which most of the Windows
components are created.

Most of the Native API calls are implemented in
[ntoskrnl.exe](https://en.wikipedia.org/wiki/Ntoskrnl.exe) and are
exposed to user mode by `ntdll.dll` The entry point of `ntdll.dll` is
`LdrInitializeThunk`. Native API calls are handled by the kernel via the
System Service Descriptor Table (SSDT).

The Native API comprises many functions. They include C runtime
functions that are needed for a very basic C runtime execution
`strlen()`, `sprintf()`, .Other common procedures like `malloc()`...are
missing. The vast majority of other Native API routines, by convention,
have a 2 or 3 letter prefix, which is:

* `Nt` or +Zw+: system calls . When called from `ntdll.dll` in user
    mode, these groups are almost exactly the same; they execute an
    interrupt into kernel mode and call the equivalent function in
    `ntoskrnl.exe` via the SSDT. When calling the functions directly in
    ntoskrnl.exe (only possible in kernel mode), the Zw variants ensure
    kernel mode, whereas the Nt variants do not.

* `Rtl` is the second largest group of ntdll calls. These comprise the
    (extended) C Run-Time Library, which includes many utility functions
    that can be used by native applications, yet don't directly involve
    kernel support.

* `Csr` are client-server functions that are used to communicate with
    the Win32 subsystem process, csrss.exe (csrss stands for
    client/server runtime sub-system).

* `Dbg` are debugging functions such as a software breakpoint.

* `Ki` are upcalls from kernel mode for events like APC dispatching.

* `Ldr` are loader functions for PE file handling and starting of new
    processes.

* `Nls` for National Language Support (similar to code pages).

* `Pfx` for prefix handling.

* `Tp` for threadpool handling.

When a function within KERNEL32.DLL is called, for example
`CreateThread`, it will make a subsequent call to the `NTAPI` equivalent
in `NTDLL.DLL`. For example, `CreateThread` calls `NtCreateThreadEx`.
This function will then fill `RAX` register with the **System Service
Number (SSN)**. Finally, `NTDLL.dll` will then issue a [SYSENTER
instruction](https://web.archive.org/web/20210618080941/http://qcd.phys.cmu.edu/QCDcluster/intel/vtune/reference/vc311.htm).
This will then cause the processor to switch to kernel mode, and jumps
to a predefined function, called the **System Service Dispatcher**.

## DLL

A DLL is a library that contains code and data that can be used by more
than one program at the same time.

These libraries are loaded into their own space in the system memory and
can be accessed by one or more processes at runtime.

The predefined search for DLLs in Windows

Before searching for the DLL in the system files, Windows does two
things. First check if the DLL is already loaded in memory. If yes, the
search process stops here. It then checks to see if the DLL belongs to a
list known as "Known DLLs". If it is in that list, the system will use
its own copy of the DLL.

### DLL search order

* The directory from which the application is loaded

* `C:\Windows\System32`

* `C:\Windows\System`

* `C:\Windows`

* The current working directory

* Directories in the system PATH environment variable

* Directories in the user PATH environment variable

### DllMain

An optional entry point into a DLL. When the system starts or terminates
a process or thread, it calls the entry-point function for each loaded
DLL using the first thread of the process. The system also calls the
entry-point function for a DLL when it is loaded or unloaded using the
`LoadLibrary` and `FreeLibrary` functions.

    BOOL WINAPI DllMain(
        _In_ HINSTANCE hinstDLL,
        _In_ DWORD     fdwReason,
        _In_ LPVOID    lpvReserved
    );

### Attacks

* [Path Interception by Search Order
    Hijacking](https://dmcxblue.gitbook.io/red-team-notes-2-0/red-team-techniques/defense-evasion/untitled-5/path-interception-by-search-order-hijacking)

* [Path Interception by PATH Environment
    Variable](https://dmcxblue.gitbook.io/red-team-notes-2-0/red-team-techniques/defense-evasion/untitled-5/path-interception-by-path-environment-variable)

* 

* DLL hijacking

* DLL injection

* [DLL
    sideloading](https://dmcxblue.gitbook.io/red-team-notes-2-0/red-team-techniques/defense-evasion/untitled-5/dll-side-loading)
