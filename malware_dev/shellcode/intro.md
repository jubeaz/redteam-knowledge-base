| üè† [Home](../../pentesting.md) | ‚¨ÖÔ∏è ‚¨ÖÔ∏è [Part](../_part) | ‚¨ÖÔ∏è [Chapter](./_chapter) |
|--------------------------------|----------------------|-------------------------|

* [Shellcode Injection](../../malware_dev/shellcode/processinjection.md)
    * [Introduction](../../malware_dev/shellcode/processinjection.md#introduction)
    * [Target finding](../../malware_dev/shellcode/processinjection.md#target-finding)
    * [DLL Injection](../../malware_dev/shellcode/processinjection.md#dll-injection)
        * [DLL Injection](../../malware_dev/shellcode/processinjection.md#dll-injection-1)
        * [DLL Sideloading](../../malware_dev/shellcode/processinjection.md#dll-sideloading)
    * [Shellcode Injection](../../malware_dev/shellcode/processinjection.md#shellcode-injection-1)
        * [Process Injection](../../malware_dev/shellcode/processinjection.md#process-injection)
        * [CreateRemoteThread](../../malware_dev/shellcode/processinjection.md#createremotethread)
        * [Process Hollowing](../../malware_dev/shellcode/processinjection.md#process-hollowing)
        * [QueueUserAPC \| EarlyBird](../../malware_dev/shellcode/processinjection.md#queueuserapc-earlybird)
    * [targets of injection](../../malware_dev/shellcode/processinjection.md#targets-of-injection)
    * [links](../../malware_dev/shellcode/processinjection.md#links)

# Shellcode Injection

## Introduction

Process injection is an evasion technique which entails running malicious code within the address space of another process. There are many ways it can be done, including:

* **DLL Injection**: write the path of a malicious DLL into the
    address space of a target process and then calls LoadLibrary.

* **DLL Sideloading**:

* **Portable Executable Injection**: copie code into the address space
    of a target process and then executes it with CreateRemoteThread.

* **Process Hollowing**: spawn a target process in a suspended state,
    replaces the entrypoint in memory and then resumes the process.

* **Thread Execution Hijacking**: suspend a thread in a target
    process, replaces the code and then resumes the thread.


## Target Finding

This is usually done by searching through processes by calling a trio of Application Program Interfaces (APIs): `CreateToolhelp32Snapshot`, `Process32First`, and `Process32Next`. `CreateToolhelp32Snapshot` is an API used for enumerating heap or module states of a specified process or all processes, and it returns a snapshot. `Process32First` retrieves information about the first process in the snapshot, and then `Process32Next` is used in a loop to iterate through them. 



## IAT hooking
https://www.ired.team/offensive-security/code-injection-process-injection/import-adress-table-iat-hooking
## DLL Injection

### DLL Hijacking

* [Adaptive DLL Hijacking](https://www.netspi.com/blog/technical-blog/adversary-simulation/adaptive-dll-hijacking/)
### DLL Injection
After finding the target process, the malware gets the handle of the target process by calling `OpenProcess`.

The malware calls `VirtualAllocEx` to have a space to write the path to its DLL. The malware then calls `WriteProcessMemory` to write the path in the allocated memory. Finally, to have the code executed in another process, the malware calls APIs such as `CreateRemoteThread`, `NtCreateThreadEx`, or `RtlCreateUserThread`. The latter two are undocumented. However, the general idea is to pass the address of `LoadLibrary` to one of these APIs so that a remote process has to execute the DLL on behalf of the malware.

`CreateRemoteThread` is tracked and flagged by many security products. Further, it requires a **malicious DLL on disk** which could be detected. 

```c
HANDLE processHandle;
PVOID remoteBuffer;
wchar_t dllPath[] = TEXT("C:\\experiments\\evilm64.dll");
	
// printf("Injecting DLL to PID: %i\n", atoi(argv[1]));
processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, DWORD(atoi(argv[1])));
remoteBuffer = VirtualAllocEx(processHandle, NULL, sizeof dllPath, MEM_COMMIT, PAGE_READWRITE);	
WriteProcessMemory(processHandle, remoteBuffer, (LPVOID)dllPath, sizeof dllPath, NULL);
PTHREAD_START_ROUTINE threatStartRoutineAddress = (PTHREAD_START_ROUTINE)GetProcAddress(GetModuleHandle(TEXT("Kernel32")), "LoadLibraryW");
CreateRemoteThread(processHandle, NULL, 0, threatStartRoutineAddress, remoteBuffer, 0, NULL);
CloseHandle(processHandle); 
```

https://github.com/rapid7/metasploit-framework/issues/18640

https://github.com/rapid7/metasploit-framework/blob/94a4a6173f22f2abda0bf35f46e09544ab09fc74/data/templates/src/pe/dll/template.c

```c
OID CALLBACK CallWithoutLoaderLock(ULONG_PTR dwParam)
{
    // Do your stuff here
}


BOOL APIENTRY DllMain( HINSTANCE hinstDLL,
                       DWORD  ul_reason_for_call,
                       LPVOID lpReserved
                     )
{ 
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        if (!QueueUserAPC(CallWithoutLoaderLock, GetCurrentThread(), 0))
            std::abort();
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}
```


**Inconvenient**: the dll is written to disk

### DLL Sideloading (aka DLL proxying)

DLL Sideloading is aiming for the very same thing as DLL Hijacking. As mentioned, the problem of the DLL Hijacking technique was that the custom DLL is lacking the needed function exports from the targeted application. To solve this problem, we should perform something called DLL Proxying, a.k.a sideloading.

DLL Proxying is a technique where we check which DLL and functions are used by the targeted program, and then we forward them to the original legitimate DLL, so that their functionality is still working. 

By doing this we ensure, that the custom DLL now exports every function that is needed from the application, which drastically lowers the chance of crashing the program. Now, when the DLL is loaded, the malicious payload will get executed in parallel with the intended and needed exported functions.

Additionally, the payload execution should not be handled carelessly, if the payload execution is done from **DllMain**, even though the exported functions are present, the application could still timeout due to for example a **LoaderLock**. To avoid locking the targeted process it is highly recommended to perform either Remote Process Injection, Remote Thread Creation, Thread Hijack, or pretty much each technique that will jump to / create a thread. But even if you do this, you might end up in a LoaderLock with a C2-Payload. For example Hooking could be used to break out of DllMain as alternative. The [Perfect DLL Hijacking](https://elliotonsecurity.com/perfect-dll-hijacking/) blog post also describes alternatives to ‚Äûsafely‚Äú run payloads from DllMain. Best chances for no LoaderLock at all however is to execute the payload from an exported function itself instead of DllMain from our experience.

The simple sequence goes like this

* Find a vulnerable DLL using Procmon
* Create a shellcode
* Create a proxy DLL of the original legitimate DLL
* Upload them to the machine and execute them

* [Guide to DLL Sideloading](https://crypt0ace.github.io/posts/DLL-Sideloading/)
* [DLL Sideloading](https://www.r-tec.net/r-tec-blog-dll-sideloading.html)



### reflective DLL injection
load the library from memory into a host process. The ReflectiveLoader will process the newly loaded copy of its image‚Äôs import table, loading any additional libraries and resolving their respective imported function addresses. The advantage of this technique is the library itself is not registered on the host system and could potentially be used to bypass memory scanning and API hooking.  


## Shellcode Injection

### Process Injection

Inject into self thread

* [Shellcode Injection in C# - Part 1 - Process Injection](https://crypt0ace.github.io/posts/Shellcode-Injection-Techniques/)
* [Learning Sliver C2 (12) - Extensions](https://dominicbreuker.com/post/learning_sliver_c2_12_extensions/)

### CreateRemoteThread

There is more than one way to achieve this, but the most common way is
by making use of the following WinAPI functions:

* [VirtualAllocEx](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualallocex):
    allocate space in the memory of the target process for our shellcode
* [WriteProcessMemory](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-writeprocessmemory)
    write our shellcode into that allocated space
* [CreateRemoteThread](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createremotethread)
    execute the shellcode in the target process

Note:

* `lpBaseAddress` of `WriteProcessMemory()` is set with the `VirtualAllocEx()` return value
* `lpStartAddress` of `CreateRemoteThread()` is set with the `VirtualAllocEx()` return value

In our case, we will additionally make use of:

* [CreateProcess](https://learn.microsoft.com/en-us/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa)
    to spawn our target process,
* [VirtualProtectEx](https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualprotectex)
    to allocate memory with Read/Write memory protection, write the
    shellcode and then set it to Read/Execute before executing.

This is not necessary, but some antivirus solutions find it suspicious
when Read/Write/Execute memory is allocated, so this is a simple
workaround.

### Process Hollowing

* [The Nightmare of Proc Hollow's Exe](https://trustedsec.com/blog/the-nightmare-of-proc-hollows-exe)
* [Process Hollowing](https://ppn.snovvcrash.rocks/red-team/maldev/code-injection/process-hollowing)
* [OSEP-Code-Snippets](https://github.com/chvancooten/OSEP-Code-Snippets/blob/main/Shellcode%20Process%20Hollowing/Program.cs)
* [DinvokeProcessHollow.cs](https://github.com/S3cur3Th1sSh1t/Creds/blob/master/Csharp/DinvokeProcessHollow.cs)
* [HollowGhost](https://github.com/Logan-Elliott/HollowGhost/blob/main/HollowGhost/Program.cs)

### QueueUserAPC | EarlyBird

* Get the process ID of the process to inject into
* Open the target process
* Allocate memory within the target process
* Write shellcode into the allocated memory
* Modify the protections of the newly allocated memory to allow execution of code from within that memory space
* Open a thread in the remote process with the start address of the allocated memory segment
* Submit thread to queue for execution when it enters an ‚Äúalertable‚Äù state
* Resume thread to enter ‚Äúalertable‚Äù state


* [Shellcode Injection in C# - Part 3 - QueueUserAPC | EarlyBird](https://crypt0ace.github.io/posts/Shellcode-Injection-Techniques-Part-3/)

## targets of injection

    teams
    msedge
    onedrive
    update executables (????)
    sihost.exe
    spoolsv.exe
    svchost.exe

## links
* [Code and Process Injection](https://www.ired.team/offensive-security/code-injection-process-injection)
* [Ten process injection techniques: A technical survey of common and trending process injection techniques](https://www.elastic.co/blog/ten-process-injection-techniques-technical-survey-common-and-trending-process)
* [Process Injection using CreateRemoteThread API](https://tbhaxor.com/createremotethread-process-injection/)
* [Process Injection: Remote Thread Injection or CreateRemoteThread](https://aliongreen.github.io/posts/remote-thread-injection.html)
* [Learning Sliver C2 (07) - Stagers: Process Injection](https://dominicbreuker.com/post/learning_sliver_c2_06_stagers_process_injection/)
* [OffensiveCSharp](https://github.com/matterpreter/OffensiveCSharp)
* [Writing custom backdoor payloads with CSharp](https://github.com/mvelazc0/defcon27_csharp_workshop)
* [SliverLoader](https://github.com/Cyb3rDudu/SliverLoader/blob/main/README.md)
* [OSEP Code Snippets](https://github.com/chvancooten/OSEP-Code-Snippets/tree/main)
* [Windows Process injection in 2019](https://i.blackhat.com/USA-19/Thursday/us-19-Kotler-Process-Injection-Techniques-Gotta-Catch-Them-All-wp.pdf)
